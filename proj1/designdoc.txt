Part 1: KThread

When a thread is joined, the calling thread needs to be kept track of. If there are multiple calling threads, we will need to keep track of them all. This means we need to add a queue to KThread to store all the joining threads.

joinQueue := empty ThreadQueue 

When the current thread calls join on another thread, the current thread will wait for the other thread to finish executing, before continuing with its own execution. This means we must sleep the calling thread, and add it to the join queue. However, if the thread is already finished executing, we should not sleep the calling thread.

function join
  assert thisThread != currentThread

  if status is finished
    return
  else
    disable interrupt
    currentThread.sleep()
    joinQueue.waitForAccess(thisThread)

end join

Once a thread has finished executing, any thread on the join queue must be reawoken. Hence, we must iterate through the join queue, and set any thread in it to ready.

function finish
  disable interrupt
  assert toBeDestroyed is null
  toBeDestroyed := currentThread

  for thread in joinQueue
    thread.ready()

  currentThreadStatus := finished
  sleep()
end finish

In Condition2, we need to create a threadQueue object.

function sleep
  assert conditionLock.isHeldByCurrentThread()
  interrupt.disable()
  conditionLock.acquire()

  threadQueue.push(currentThread)
  currentThread.sleep()

  conditionLock.release()
  interrupt.enable()
end sleep

function wake
  assert conditionLock.isHeldByCurrentThread()
  interrupt.disable()

  thread := threadQueue.nextThread()
  if thread is not null
    thread.ready()

  interrupt.enable()
end wake

function wakeAll
  assert conditionLock.isHeldByCurrentThread()
  while threadQueue is not empty
    wake()
end wakeAll
** NOTE : May need to call interrupt.enable(), but I don't think we do. **

TASK 3:

-- TimerThread

A TimerThread class contains an instance variable for a KThread, and a time (UNIX timestamp, represented as a long). It implements comparable, which will allow TimerThread objects to be sorted in ascending order, based around the wake time. For example, KThread(t1, 1000) < KThread(t2, 1001).

class TimeThread:

  var wakeThread (KThread)
  var wakeTime (Long)

  constructor(thread:KThread, time:Long):
    wakeThread := thread
    wakeTime := clockTime + time

end TimeThread

--PriorityQueue

The priority queue 

class PriorityQueue

  

end PriorityQueue

***************************** Alarm.java *****************************
Class for waiting threads that includes the thread and wake time, implements comparable.
heap data structure to store waiting threads in.

timerInterrupt will check if time >= wake time of top of the heap structure, if it is, it will move that thread to the ready queue and then loop to see if any other threads are ready to wake.

function timerInterrupt:
  if waitQueue is empty
    return
  while waitQueue.peek().wakeTime <= clockTime
    waitQueue.pop().wakeThread.ready()

  currentThread.yield()
end timerInterrupt
 
function waitUntil: var time (Long)
  disable interrupt
  timeThread := TimeThread(currentThread, time)	
  waitQueue.push(timeThread)
  currentThread.sleep()
  enable interrupts 
end waitUntil
**********************************************************************

-- TASK 4

Communicator

communicatorLock : Lock
speakCondition : Condition
listenCondition : Condition
listenCount : Int
speakCount : Int
message : Int

For each Communicator instance, there is one lock that is shared between two conditions. Both conditions keep track of threads that are listening and speaking respectively.

constructor
  communicatorLock := Lock()
  speakCondition := Condition2(communicatorLock)
  listenCondition := Condition2(communicatorLock)
end constructor

function speak(word:Int)
  communicatorLock.acquire()
  
  if listenCount > 0
    listenCondition.wake()
  else
    speakCount += 1
    speakCondition.sleep()
    speakCount -= 1
  
  message = word
  
  communicatorLock.release()
end speak

function listen -> Int
  communicatorLock.acquire()

  if speakCount > 0
    speakCondition.wake()
  else
    listenCount += 1
    listenCondition.sleep()
    listenCount -= 1

  communicatorLock.release()
  return message
end speak