Part 1: KThread

When a thread is joined, the calling thread needs to be kept track of. If there are multiple calling threads, we will need to keep track of them all. This means we need to add a queue to KThread to store all the joining threads.

joinQueue := empty ThreadQueue 

When the current thread calls join on another thread, the current thread will wait for the other thread to finish executing, before continuing with its own execution. This means we must sleep the calling thread, and add it to the join queue. However, if the thread is already finished executing, we should not sleep the calling thread.

function join
  assert thisThread != currentThread

  if status is finished
    return
  else
    disable interrupts
    joinQueue.waitForAccess(thisThread)
    currentThread.sleep()
    reenable interrupts

end join

Once a thread has finished executing, any thread on the join queue must be reawoken. Hence, we must iterate through the join queue, and set any thread in it to ready.

function finish
  disable interrupt
  assert toBeDestroyed is null
  toBeDestroyed := currentThread

  for thread in joinQueue
    thread.ready()

  currentThreadStatus := finished
  sleep()
  enable interrupt
end finish

KThread Test Cases:
Case 1: A thread attempts to join an uncompleted threed. This will put the current thread to sleep and put the thread on the wait queue.  
Case 2: A thread attempts to join a non-existent thread. This will cause an exception because there would be a null pointer.  
Case 3: A thread attempts to join itself. This will crash the system due to the assertion that thisThread != currentThread.
Case 4: A thread attempts to join a previously joined thread, creating a cycle. Our implementation will check to see if the thread id is unique in the join, if it isn't, it will cause an exception.
Case 5: A thread attempts to join a finished thread. This will just return. 
Case 6: Finish runs on a completed thread. This will cause the toBeDestroyed to be set to the currentThread, threads in its joinQueue will be set to ready, its status will be set to ready and then it will      
slept until it is destroyed.    




In Condition2, we need to create a threadQueue object.

function sleep
  assert conditionLock.isHeldByCurrentThread()
  interrupt.disable()
  conditionLock.acquire()

  threadQueue.push(currentThread)
  currentThread.sleep()

  conditionLock.release()
  interrupt.enable()
end sleep

function wake
  assert conditionLock.isHeldByCurrentThread()
  interrupt.disable()

  thread := threadQueue.nextThread()
  if thread is not null
    thread.ready()

  interrupt.enable()
end wake

function wakeAll
  assert conditionLock.isHeldByCurrentThread()
  while threadQueue is not empty
    wake()
end wakeAll
** NOTE : May need to call interrupt.enable(), but I don't think we do. **

TASK 3:

-- TimerThread

A TimerThread class contains an instance variable for a KThread, and a time (UNIX timestamp, represented as a long). It implements comparable, which will allow TimerThread objects to be sorted in ascending order, based around the wake time. For example, KThread(t1, 1000) < KThread(t2, 1001).

class TimeThread implements Comparable:

  var wakeThread (KThread)
  var wakeTime (Long)

  constructor(thread:KThread, time:Long):
    wakeThread := thread
    wakeTime := clockTime + time
  end constructor

end TimeThread

--PriorityQueue

A PriorityQueue class uses a LinkedList, ordering the queue by earliest wakeTime

class PriorityQueue
  
  list LinkedList<Tthread> implements Queue
  
  constructor(Tthread : TimeThread):
    insert(Tthread)
  end constructor
  
  void insert(Tthread : TimeThread){
    Node curr = list.head
	while(curr.compareTo(Tthread) > 0){curr = curr.next}
	Node nextNode = curr.next
	curr.setNext(new Node(Tthread))
	curr.next.setNext(nextNode)
  }
  
  TimeThread getFirst(){return list.remove()}
    
end PriorityQueue

***************************** Alarm.java *****************************
The alarm class will be implemented with a class for waiting threads that implements the comparable interface in java. This class will be used to store the current thread that needs to wait as well as the time  that it has been designated to wait. Within the class, the thread will be set to the thread it is passed and the wake time will be set as the time the constructor recieves plus the current clock time. These wait-ing threads will be then be put into a priority queue implemented as a heap data structure. The heap will keep the value with the smallest (soonest) wake time at the top position making it the trivial to check the soonest waking thread and wake if necessary.
 
timerInterrupt will check if time >= wake time of top of the heap structure, if it is, it will move that thread to the ready queue and then loop to see if any other threads are ready to wake.

function timerInterrupt:
  if waitQueue is empty
    return
  while waitQueue.peek().wakeTime <= clockTime
    waitQueue.pop().wakeThread.ready()

  currentThread.yield()
end timerInterrupt

waitUntil(long time) will be used to sleep a thread for at least x milliseconds. A new TimeThread instance is created using the current thread and the time passed in the parameter. It is then pushed on the priority queue and the thread is slept.  
 
function waitUntil: var time (Long)
  disable interrupts
  timeThread := TimeThread(currentThread, time)	
  waitQueue.push(timeThread)
  currentThread.sleep()
  enable interrupts 
end waitUntil


Alarm Test Cases:
Case 1: calling waitUntil on a thread using a positive number. The thread should create an instance of TimeThread and add it to the waitqueue, then sleep the thread.
Case 2: calling waitUntil on a thread using a negative number. The thread should create an instance of TimeThread and add it to the waitqueue, then sleep the thread. (Will be removed at next timer interrupt) 
Case 3: calling timerInterrupt if the waitQueue is empty. The method will just return.
Case 4: calling timerInterrupt with one wakable (waketime <= clockTime) node. The method will wake the thread and move it onto the ready queue, then it will yield the current thread.
Case 5: calling timerInterrupt with mutliple wakable nodes. The method will wake the thread at the top of the queue, then it will continuing looping through the heap, waking the nodes that are wakable. Then it
will yield the current thread.  

**********************************************************************

-- TASK 4

Communicator

For each Communicator instance, there is one lock that is shared between two conditions. Both conditions keep track of threads that are listening and speaking respectively. There are also counters to keep track of how many listeners and speakers are waiting, though it should be noted that there should be no case where both the speak count and listen count are greater than 0 at the same time. Finally, there is a message instance variable which is used to share the message across both connected threads (once the communication is established).

communicatorLock : Lock
speakCondition : Condition
listenCondition : Condition
listenCount : Int
speakCount : Int
message : Int

constructor
  communicatorLock := Lock()
  speakCondition := Condition2(communicatorLock)
  listenCondition := Condition2(communicatorLock)
end constructor

Checks if the listen count is greater than 0, which means the speaker can be paired up with the speaker immediately by waking up the listener. Since the speaker must finish executing before the listener (to have the communicator's instance variable appropriately set before returning), we will wake the next listener thread on the condition queue, but not yield to it. However, if the listen count is 0, we must increment the speak count and call the speak condition's sleep function, which will add the current thread to the condition's queue, before sleeping it. Once the thread is reawoken (after it is paired with a listener), the speak count must be decremented. Finally, the speaker must set the communicator's message instance variable to be the word passed in as a parameter to the speak function. (This message will later be accessed by the paired listener.) 

function speak(word:Int)
  communicatorLock.acquire()
  
  if listenCount > 0
    listenCondition.wake()
    communicatorLock.release()
  else
    speakCount += 1
    speakCondition.sleep()
    speakCount -= 1
  
  message = word
  
end speak

Checks if the speak count is greater than 0, which means the listener can be paired up with the speaker immediately by waking up the speaker, and yielding the current thread (so that the speaker has a chance to finish execution, setting the message instance variable, before the listener returns the message). Otherwise, if there are no speakers (speak count is 0), we must increment the listen count before calling the listen condition's sleep function, which will add the current thread to the condition's queue, and sleep it. Once the thread is reawoken, the listen count must be decremented. By this point, the speaker that was paired with this thread will have set the communicator's message instance variable, which is then returned.

function listen -> Int
  communicatorLock.acquire()

  if speakCount > 0
    speakCondition.wake()
    communicatorLock.release()
    currentThread.yield()
  else
    listenCount += 1
    listenCondition.sleep()
    listenCount -= 1
    communicatorLock.release()

  return message
end speak

-- TASK 5

A ReactWater instance will keep track of oxygen threads and hydrogen threads. Oxygen and Hydrogen threads can be added to the thread queues in their respective conditions, with the hCount and oCounts being used to keep track of how many oxygen and hydrogen threads exist. Both of the conditions will share the same lock.

waterLock : Lock
hCount : Int
oCount : Int
hCondition : Condition
oCondition : Condition

constructor
  hCount := 0
  oCount := 0
  waterLock := Lock()
  hCondition := Condition(waterLock)
  oCondition := Condition(waterLock)
end constructor

The calling thread will be treated as Oxygen. If there are already 2 hydrogen stored in the hydrogen condition queue, then we have all the elements necessary to create water. We must wake up two hydrogen threads, subtract 2 from the hydrogen count, and then call the make water function. Otherwise, if there is not enough hydrogen to form water, we must increment the oxygen count by 1 and call sleep on the oxygen condition (which will add the current thread to its queue, and sleep it). 

function oReady
  waterLock.acquire()
  if hCount >= 2
    hCondition.wake()
    hCondition.wake()
    hCount -= 2
    makeWater()
  else
    oCount += 1
    oCondition.sleep()

  waterLock.release()    
end oReady

The calling thread will be treated as Hydrogen. If there are already 1 oxygen and 1 hydrogen stored in their respective condition queues, we have all the elements necessary to create water. We must wake one oxygen and one hydrogen thread, and subtract one from both the hydrogen count and oxygen count. Afterwards, we make a call to the create water function. Otherwise, if there is not enough hydrogen or no oxygen available, we must increment the hydrogen count by one, and call sleep on the hydrogen condition (which will add the current thread to its queue, and sleep it).

function hReady
  waterLock.acquire()
  if hCount > 0 and oCount > 0
    hCondition.wake()
    oCondition.waker()
    hCount -= 1
    oCount -= 1
    makeWater()
  else
    hCount += 1
    hCondition.sleep()

  waterLock.release()

end hReady

This function is called when water is successfully made. The implementation simply prints a statement indicating that water was, in fact, made.

function makeWater
  print "Water was made!"
end makeWater
