Part 1: KThread

When a thread is joined, the calling thread needs to be kept track of. If there are multiple calling threads, we will need to keep track of them all. This means we need to add a queue to KThread to store all the joining threads.

joinQueue := empty ThreadQueue 

Synchronization is required while joining threads. We must define a lock for joining.

jLock := an available lock

When the current thread calls join on another thread, the current thread will wait for the other thread to finish executing, before continuing with its own execution. This means we must sleep the calling thread, and add it to the join queue. However, if the thread is already finished executing, we should not sleep the calling thread.

function join
  assert thisThread != currentThread

  jLock.acquire()
  if status is finished
    return
  else
    disable interrupt
    currentThread.sleep()
    joinQueue.waitForAccess(thisThread)
  jLock.release()

end join

Once a thread has finished executing, any thread on the join queue must be reawoken. Hence, we must iterate through the join queue, and set any thread in it to ready.

function finish
  disable interrupt
  assert toBeDestroyed is null
  toBeDestroyed := currentThread

  jLock.acquire()
  for thread in joinQueue
    thread.ready()
  jLock.release()

  currentThreadStatus := finished
  sleep()
end finish

In Condition2, we need to create a threadQueue object.

function sleep
  assert conditionLock.isHeldByCurrentThread()
  interrupt.disable()
  conditionLock.release()

  threadQueue.push(currentThread)
  currentThread.sleep()

  conditionLock.acquire()
  interrupt.enable()
end sleep

function wake
  assert conditionLock.isHeldByCurrentThread()
  interrupt.disable()

  thread := threadQueue.nextThread()
  if thread is not null
    thread.ready()

  interrupt.enable()
end wake

function wakeAll
  assert conditionLock.isHeldByCurrentThread()
  while threadQueue is not empty
    wake()
end wakeAll
** NOTE : May need to call interrupt.enable(), but I don't think we do. **

***************************** Alarm.java *****************************
Class for waiting threads that includes the thread and wake time, implements comparable.
heap data structure to store waiting threads in.

timerInterrupt will check if time >= wake time of top of the heap structure, if it is, it will move that thread to the ready queue and then loop to see if any other threads are ready to wake.

timerInterrupt(){
	if waiting heap is empty or the first elements time is greater than current time then return 			done;
	if the first elements time is less than the current time then
		while the first elements time is less than the current time do
			wake the thread and move it to the ready queue.
			restructure heap if necessary
		done
	done
	KThread.currentThread().yield();
} 
waitUntil(int x) {
	Disable interrupts
	Lose the lock
	wakeTime = clock time + x	
	create new waiting thread object including the current thread and wake time. 
	add the new waiting thread to the heap data structure.
	sleep the thread.
	enable interrupts 
}
**********************************************************************