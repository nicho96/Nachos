Part 1: KThread
//COLLIN WAS HERE
When a thread is joined, the calling thread needs to be kept track of. If there are multiple calling threads, we will need to keep track of them all. This means we need to add a queue to KThread to store all the joining threads.

joinQueue := empty ThreadQueue 

When the current thread calls join on another thread, the current thread will wait for the other thread to finish executing, before continuing with its own execution. This means we must sleep the calling thread, and add it to the join queue. However, if the thread is already finished executing, we should not sleep the calling thread.

function join
  assert thisThread != currentThread

  if status is finished
    return
  else
    disable interrupt
    currentThread.sleep()
    joinQueue.waitForAccess(thisThread)

end join

Once a thread has finished executing, any thread on the join queue must be reawoken. Hence, we must iterate through the join queue, and set any thread in it to ready.

function finish
  disable interrupt
  assert toBeDestroyed is null
  toBeDestroyed := currentThread

  for thread in joinQueue
    thread.ready()

  currentThreadStatus := finished
  sleep()
end finish

In Condition2, we need to create a threadQueue object.

function sleep
  assert conditionLock.isHeldByCurrentThread()
  interrupt.disable()
  conditionLock.acquire()

  threadQueue.push(currentThread)
  currentThread.sleep()

  conditionLock.release()
  interrupt.enable()
end sleep

function wake
  assert conditionLock.isHeldByCurrentThread()
  interrupt.disable()

  thread := threadQueue.nextThread()
  if thread is not null
    thread.ready()

  interrupt.enable()
end wake

function wakeAll
  assert conditionLock.isHeldByCurrentThread()
  while threadQueue is not empty
    wake()
end wakeAll
** NOTE : May need to call interrupt.enable(), but I don't think we do. **

TASK 3:

-- TimerThread

A TimerThread class contains an instance variable for a KThread, and a time (UNIX timestamp, represented as a long). It implements comparable, which will allow TimerThread objects to be sorted in ascending order, based around the wake time. For example, KThread(t1, 1000) < KThread(t2, 1001).

class TimeThread:

  var wakeThread (KThread)
  var wakeTime (Long)

  constructor(thread:KThread, time:Long):
    wakeThread := thread
    wakeTime := clockTime + time

end TimeThread

--PriorityQueue

The priority queue 

class PriorityQueue

  

end PriorityQueue

***************************** Alarm.java *****************************
Class for waiting threads that includes the thread and wake time, implements comparable.
heap data structure to store waiting threads in.

timerInterrupt will check if time >= wake time of top of the heap structure, if it is, it will move that thread to the ready queue and then loop to see if any other threads are ready to wake.

function timerInterrupt:
  if waitQueue is empty
    return
  while waitQueue.peek().wakeTime <= clockTime
    waitQueue.pop().wakeThread.ready()

  currentThread.yield()
end timerInterrupt
 
function waitUntil: var time (Long)
  disable interrupt
  timeThread := TimeThread(currentThread, time)	
  waitQueue.push(timeThread)
  currentThread.sleep()
  enable interrupts 
end waitUntil
**********************************************************************

-- TASK 4

Communicator

communicatorLock : Lock
speakCondition : Condition
listenCondition : Condition
listenCount : Int
speakCount : Int
message : Int

For each Communicator instance, there is one lock that is shared between two conditions. Both conditions keep track of threads that are listening and speaking respectively. There are also counters to keep track of how many listeners and speakers are waiting, though it should be noted that there should be no case where both the speak count and listen count are greater than 0 at the same time. Finally, there is a message instance variable which is used to share the message across both connected threads (once the communication is established).

constructor
  communicatorLock := Lock()
  speakCondition := Condition2(communicatorLock)
  listenCondition := Condition2(communicatorLock)
end constructor

Checks if the listen count is greater than 0, which means the speaker can be paired up with the speaker immediately by waking up the listener. Since the speaker must finish executing before the listener (to have the communicator's instance variable appropriately set before returning), we will wake the next listener thread on the condition queue, but not yield to it. However, if the listen count is 0, we must increment the speak count and call the speak condition's sleep function, which will add the current thread to the condition's queue, before sleeping it. Once the thread is reawoken (after it is paired with a listener), the speak count must be decremented. Finally, the speaker must set the communicator's message instance variable to be the word passed in as a parameter to the speak function. (This message will later be accessed by the paired listene.r) 

function speak(word:Int)
  communicatorLock.acquire()
  
  if listenCount > 0
    listenCondition.wake()
  else
    speakCount += 1
    speakCondition.sleep()
    speakCount -= 1
  
  message = word
  
  communicatorLock.release()
end speak

Checks if the speak count is greater than 0, which means the listener can be paired up with the speaker immediately by waking up the speaker, and yielding the current thread (so that the speaker has a chance to finish execution, setting the message instance variable, before the listener returns the message). Otherwise, if there are no speakers (speak count is 0), we must increment the listen count before calling the listen condition's sleep function, which will add the current thread to the condition's queue, and sleep it. Once the thread is reawoken, the listen count must be decremented. By this point, the speaker that was paired with this thread will have set the communicator's message instance variable, which is then returned.

function listen -> Int
  communicatorLock.acquire()

  if speakCount > 0
    speakCondition.wake()
    currentThread.yield()
  else
    listenCount += 1
    listenCondition.sleep()
    listenCount -= 1

  communicatorLock.release()
  return message
end speak

Luke was here
